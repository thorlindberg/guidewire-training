{
    "InsuranceSuite 10.0 Developer Fundamentals": {
        "Kickstart Lessons": {
            "Introduction to Guidewire Configuration": {
                "Three tiers": "Data, Application, Presentation",
                "Data tier": "Business and operational data. Relational database supporting Oracle Enterprise, Microsoft SQL Server, and H2 (training).",
                "Application tier": "Functional process and business logic. Written in Gosu lang. Supports application servers WebSphere, WebLogic, Apache Tomcat, JBoss EAP, and Jetty (training).",
                "Presentation tier": "User interface. Generates HTML. Browser support for Chrome, Firefox, MS Internet Explorer, and MS Edge.",
                "Data model entity": "An object typically corresponding to a table in the database. Defined as one or more XML files.",
                "Java class": "One-to-one relationship with data entities. Each field in an entity generates and populates a field in the Java class instance at runtime.",
                "Gosu code": "Business logic for runtime operations.",
                "Page Configuration Format (PCF)": "A set of one or more XML files using PCF XML schema definition.",
                "Process": "Interface action -> Java class instance -> Initialize instance with database data -> Class as input to PCF -> PCF elements accessible with dot-notation -> rendered as HTML.",
                "Guidewire platform": "Technology for configuring data model, user interface, application logic, and integration mechanisms. Each application on this platform has specific functionality under these technologies.",
                "Training environment": "TrainingApp is a training project based on the ContactManager application and maintained by Guidewire Education.",
                "Gradle": "Open-source build automation tool. View tasks by running: gwb tasks.",
                "Guidewire Studio": "Integrated Development Environment (IDE) based on IntelliJ IDEA."
            },
            "Introduction to the Data Model": {
                "Guidewire data model": "A set of XML metadata defining entities and typelists.",
                "Metadata loading": "Instantiates the data model as tables in database, then injects Java and Gosy classes in application server as interface to database.",
                "Data model entities": "High-level business objects. Root object for PCF file and gosu rule.",
                "Entity field": "Data: column. Relationship: foreign key, array, typekey.",
                "Data field": "Single value and not a reference to other object or table. Examples: varchar, datetime, bit, integer.",
                "Foreign key field": "Reference to related object in data model. Defines unidirectional relationship.",
                "Array field": "Defines association to set of entities of same type. Not stored in database, and populated at runtime.",
                "Typelist": "Possible values that limit field values. Typically rendered as dropdown list.",
                "Typekey field": "Association to typelist. Points to single value in the typelist.",
                "Supertype (subtyped) entity": "Hierarchy of property and method inheritance between entities.",
                "Entity in database": "Entity stores data in a database table named for the entity.",
                "Data field in database": "Physical (storage) or virtual (memory). Physical fields correspond to columns in database table. Gosu virtual fields are not stored in database.",
                "Typelist and typekey fields in database": "Typelist is stored as table that does not change during runtime. Typekey is foreign key to row in typelist table.",
                "Subtype entity in database": "Contains all instances of self and subtype. Uses null values for irrelevant subtype fields. Virtual typelists are automatically generated for subtype entities.",
                "Data dictionary": "Documentation for entities and typelists in application. Manually regenerated. Rendered as HTML in ../build/dictionary/data/index.html."
            },
            "Extending the Data Model": {
                "Entity": "Describes business object used in application. Defined with XML file and extension .ETI. Two main types: base application and custom.",
                "Base application entity": "Created by Guidewire and shipped with standard configuration. Either platform or application level. Platform entities are common to all application. Application entities are specific to application.",
                "Custom entity": "Created by users. Application level. Local inside application.",
                "Entity extension": "Extends or overrides attributes of read-only base application entities. Defined with XML file and extension .ETX. Maximum one extension file per entity. Added fields should be named with suffix _Ext.",
                "Internal Entity Extension": "Created by Guidewire to add application level extensions to platform level entities. Defined with XML file and extension .EIX. Local and read-only inside application.",
                "Extensions": "Adds fields to existing classes. Does not create a new subclass of a parent superclass, unlike some OOP languages.",
                "Typelist": "Fixed and predfined list of values (typecodes). Defines constraints of user interface.",
                "Typelist extension": "Adds new typecodes to base application typelist. Defined with XML file and extension .TTX. Maximum one extension file per typelist. Added typecodes should be named with suffix _Ext.",
                "Typelists in data model": "Similar to entity. Platform and base application typelists in ../metadata/typelist. Extensions in ../extension/typelist. Virtual typelists not available as .TTI files."
            },
            "The User Interface Architecture": {
                "User interface framework": "Page Configuration Format (PCF) is a properietary and graphical environment for creating and editing end-user interfaces.",
                "Atomic widget": "Displays single value nad has single action. Individisble widget.",
                "Container widget": "Collection of atomic widgets and/or other container widgets. Logical organization of data and functionality.",
                "Primary container widget": "Reusable view that organizes atomic widgets. Examples: detail view, list view, input set.",
                "Detail view panels": "CRUD operations on data records. Columns of data.",
                "List view panels": "Tabular representation of multiple data records. Use a small number of atomic widgets.",
                "Input sets": "Collection of grouped atomic widgets. Must be embedded into detail view panel.",
                "Secondary container widget": "Organizes primary containers. Examples: list detail panel, card.",
                "List detail panel": "Contains top list iew and bottom view panel displaying selected data.",
                "Card": "Collection of cards with each card containing detail views or list views.",
                "Top-level container widget": "Organizes primary and secondary containers. Example: screen.",
                "Screen": "Container for atomic widgets and primary/secondary views.",
                "Location": "A PCF element that is a navigation target. System permissions control and limit user read/write access."
            },
            "Atomic Widgets": {
                "Atomic widget": "Graphical user interface. Non-divisible element. Displays single value. Has single action. Data binding to input/cell widgets. Data values associated with root objects, query objects, or related objects.",
                "Display keys": "Localization keys displayed as labels for widgets. Keys are reusable.",
                "Dot notation": "A gosu lang syntax to access object properties and methods."
            },
            "Detail Views": {
                "Detail view": "Primary container. One or more records. CRUD operations on data records. Input columns. Can be referenced by views.",
                "Inline widget": "Not reusable. Inherits parent root object. Created as widget in parent container PCF file.",
                "PCF file": "Reusable. Takes root object. Filename ends with DV.",
                "Toolbar": "Horizontal bar containing buttons and widgets. Used on-top of or before panel. Provides edit buttons.",
                "Edit buttons": "Pre-defined toolbar buttons for edit functionality."
            },
            "Introductions to Locations": {
                "Location": "PCF element that is a navigation target. Not visual, but can contain visual screen containers. Use system permissions to determine user read/write access.",
                "Page": "Contain a single screen. Used esxclusively within location groups.",
                "Location group": "Collection of pages, each with their own screen. Grouped pages share a common navigation interface, such as sidebar, menu and tab bar.",
                "Wizars": "Ordered collection of screens to execute a complex business process. Screens are ordered and the process is stepwise.",
                "Popup": "Contains single screen and mimics the behavior of browser windows. Contains navigation link to previous screen.",
                "Worksheet": "Contains single screen rendered in workspace frame.",
                "Forward": "Logic executed upon navigation request. Often used to conditionally determine navigation target.",
                "Exit point": "Navigation link to external URL. Often used to access other applications or websites. Not displayed as screen widget."
            },
            "Introduction to Gosu": {
                "Guidewire Gosu": "Compatible with Java. Both procedural and object-oriented. Fundamental application behavior, complex business processes, hierarchical Gosu Rules, and dynamic UI.",
                "Gosu rule": "Conditional actions, such as navigation. Tests conditions and performs actions. Examples: Event Fired rules, Pre-update rules, and Validation rules.",
                "Entity enhancement": "Extend entity functionality through entity methods.",
                "Entity name": "Defines displayed name of entity instance.",
                "Gosu class": "Encapsulates adata and codes for specific purpose or function.",
                "Workflow": "Asynchronous execution of business processes, with optional multiple state transition over time.",
                "Gosu Scratchpad": "Embedded code editor for writing, executing and debugging Gosu code snippets.",
                "Arrays": "Used to associate a main entity with a set of entities of same type.",
                "Array methods": "Gosu block expression. Used to get information about array or conditional information about its members.",
                "array.hasMatch(/ n -> condition)": "Determine if element in array matches condition.",
                "array.countWhere(/ n -> condition)": "Count number of elements in array that match condition.",
                "array.firstWhere(/ n -> condition)": "Retrieve first element matching condition.",
                "array.where(/ n -> condition)": "Retrieves target array consiting of elements matching condition.",
                "Block expression": "Logic passed to a method as argument. Consists of block identifier (/), an element name (n), arrow (->), and a condition.",
                "Rational number libraries": "gw.util.Rational provides an infinite scale of rational numbers. gw.util.money and gw.util.science store rational numbers.",
                "Arithmetic operators": "Rational.add(i), Rational.subtract(i), Rational.multiply(i), and Rational.divide(i).",
                "Rational class": "Gosu provides a Rational.class for rational numbers."
            },
            "Gosu Rules": {
                "Gosu rule": "A gosu class with the file extension .gr. A single decision using syntax If { conditions } Then { actions }.",
                "Rule anatomy": "Root entity, name, condition, and action.",
                "Root entity": "Input parameter for the rule.",
                "Name": "Unique name for the rule. Follows naming conventions.",
                "Condition": "Expression evaluating to Bool.",
                "Action": "Executes if condition evalutes to true.",
                "Rule hierarchy": "Rule set category -> Rule set -> Rules.",
                "Rule set category": "Collection of rule sets with high-level business purpose and trigger (event) in cmmon.",
                "Rule set": "Combination of individiual rules into a group. Defines the root entity type.",
                "Rule": "Consists of root entity, expression, and action. Rules can have child rules. Guidewire executes all children if evaluated to true.",
                "Rule execution types": "Execution can either be of type execute all or exit after first action.",
                "Execute all": "Upon event trigger and condition evaluating to true, all rules in rule set are executed.",
                "Exit after first action": "Upon event trigger the first condition evaluating to true is executed, and then its first child evaluating to true. This runs recursively in the hierarchy."
            },
            "Enhancements": {
                "Gosu enhancement": "Augments classes and types with additional methods and properties. Examples: guidewire entities, and java class. Enhancement is inherited by subtypes/subclasses.",
                "Enhancement components": "getter property, setter property, and function.",
                "Getter property": "Calculates derived values. Not in data model. No input parameters. Returns values, does not alter data. Null safe.",
                "Setter property": "Takes input parameters. Value stored in database. Single input parameter. Modifies associated object.",
                "Function": "Sets field values based on logic. Modifies and creates objects. Any number of parameters. Optionally returns value.",
                "Derived (virtual) properties": "Calculated properties that are not stored in the database. Calcualted from physical fields.",
                "Java enhancement": "Gosu enhancements for Java types. Extends the functinoality of base data type. Typically contain static functions.",
                "Static method/function": "Called on the constructor itself.",
                "Instance method": "Called on an object instance."
            },
            "Code Generation and Debugging": {
                "Code generator": "Processes a Guidewire resource in XML and produces a Gosu or Java class. Two types: incremental and bulk.",
                "Incremental generator": "Processes one or more resource files in isolation from each other. Invoked on save or project make. Supports PCF, entities, typelists, and permissions.",
                "Bulk code generator": "Processes a set of resources as a whole, and thus takes longer than incremental generation. Invoked through codegen menu or project rebuild. Supports metadata, PCF, permissions, localization, and XML classes.",
                "User interface debugging": "Guidewire provides both programmatic and graphical options for debugging UI.",
                "Breakpoints": "Breakpoint indicator in Gosu or Java code. Execution is suspended when a breakpoint is hit, and line is highlighted.",
                "Debugging tools": "Toolbar, stepper, frames, variables, and watches.",
                "Web debugging": "Web UI provides debugging tools for highlighting widget sizes, and labelling widgets inline."
            }
        },
        "Essentials Lessons": {
            "Creating New Entities": {
                "Entity in data model": "Business object used by application. Defined in file with .ETI extension. Two types: base and custom.",
                "Custom entity": "Created by customer. Only on the application. Local inside application.",
                "Virtual entity": "Non-persistent entity. Exist during runtime. Not recommended by Guidewire.",
                "Subtype entity": "Children entities of a top level supertype (parent) entitity. Inherits parent fields. Supertypes and subtypes share one database table.",
                "Entity in object model": "Java classes generated from entities.",
                "Foreign key": "Pointer to single instance of other entity.",
                "Array": "Collection of pointers to instances of other entity. Maintained by code during runtime. Requires reverse foreign key.",
                "One-to-one relationship": "<onetoone> element defines single-valued association to other entity with one-to-one cardinality.",
                "Many-to-many relationship": "Requires type versionable entity that represents many-to.many relationship with: two or more nullable foreign keys or unique index for all foreign keys.",
                "Circular relationship": "<edgeForeignKey> creates edge table that links one entity to other or self, and ensures safe ordering of data insertion and deletion."
            },
            "List Views": {
                "List View Panel": "Container widget enabling the user to view and edit the list of items in the database.",
                "List View Panel structure": "Takes single root object with array of entities. Row Iterator processes array and produces row for each entity instance. Row contains one or more cell widgets. Cell displays individual entity field.",
                "Row Iterator": "Iterator is a widget that takes item set and performs the same actions for each member. Row Iterator takes object set (array or query results) and renders rows.",
                "Row Iterator required properties": "value, valueType, elementName, and editable.",
                "value": "The set of elements to process.",
                "valueType": "The type of the set of elements.",
                "elementName": "Points to object in array associated with row. Indicates the most recently processed object.",
                "editable": "Boolean value indicating whether row is editable.",
                "List View PCF": "Reusable. Takes root object. Created as eparate PCF file and filename ending with LV.",
                "List View Widget": " Not reusable. Inherits parent root object. Created as widget in parent container's PCF.",
                "Toolbar": "Horizontal bar containing buttons and widget. Can be added to screen, panel ref, or list view input. Every List View Panle must have associated toolbar. Automatically provides pagination when needed."
            },
            "Editable List Views": {
                "Iterator Buttons widget": "Contains two buttons: add and remove. Provides functionality: adds new rows and removes existing rows. Visbility and availability logic is automatically inherited.",
                "Toolbar": "Best position for edit button is screen level toolbar. Best position for iterator buttons is toolbar closest to List View.",
                "Row Iterator buttons": "Configuration of row iterator properties govern iterator buttons functionality.",
                "Editable hierarchy": "Cells become editable when row iterator is set to editable. List View panel and Row inherit editable from parent. List View panels can include editable and non-editable cells."
            },
            "Typelists": {
                "Typelist": "Fixed, predefined list of values (typecodes). Can't be dynamically altered during runtime. Constrains user input. Typically appears in UI as dropdown.",
                "Typekey field": "Entity field associated with typelist. Referenced typelist contains possible values for typekey field.",
                "Typelist kinds": "internal, custom, and extendable.",
                "Internal typelist": "Base application logic, cannot be modified or extendend, read-only, some virtual.",
                "Custom typelist": "Created by users in custom configuration.",
                "Extendable type list": "Base application. Users can modify typelist and extend.",
                "Typelist in data model": "Defined as XML with extensions .TTI, .TIX, and .TTX. Platform/base application typelists in ../metadata/typelist. Extensions in ../extensions/typelist. Virtual typelists don't exist in data model.",
                "Typelists and typekey fields in database": "Typelists stored as database tables, with types stored as rows. Typekeys stored as foreign key columns in entity table.",
                "Typelists and typekeys in object model": "Java classes generated from typelists. Typecodes become static final properties of class.",
                "Typefilter": "Typelist filter delimiting subset of typecodes. Typelsit can have multiple filters. Typekey field can reference maximum one typefilter from associated typelist."
            },
            "Popups": {
                "Browser windows": "Blocked by users, even on trusted websites. Data binding causes synchronization problems. Multiple instances or main window closed but popup open.",
                "Guidewire windows": "Functionally similar to browser windows but avoid issues."
            },
            "Validation": {
                "Pattern matching": "Field-level validation technique. Verifies input contents. Main components: regular expression and input mask (optional).",
                "Regular expression": "Abstract pattern. Examples: email address and routing number.",
                "Input mask": "Watermark in field and mouseover tooltip.",
                "Pattern matching in data model": "Compliance enforced in UI and API. Full localization support. Robust extensibility. Reusable validation. Business logic can not drive static values.",
                "Pattern matching in user interface": "Business logic can drive dynamic values. Restricts data commit. Implemented as widget properties. Only few widgets support it, configuration per widget, no custom error messages, and extensibility concerns.",
                "Validation expression": "Logical Gosu expression associated with single atomci widget implementing field-level validation. Save is allowed on null return, and prevented on string return (error message). Configured as widget property. Input validated on update.",
                "Validation rule": "Written as Gosu rules and validate (complex) logical conditions and relationships between entity fields. Ensures logical data input, fulfillment of required input, and manages relationships. Input validated on save.",
                "Delegate": "Models capability and allows functionality sharing across data model. Virtual object defined in data model, consisting of database fields and methods reusable by multiple entities. One-to-many relationship between entity and delegates.",
                "triggersValidation attribute": "Boolean attribute that controls whether validation is performed on save."
            },
            "Input Sets": {
                "Input set": "Set of grouped atomic widgets. Reusable. Common visibility/editability. Fit attributes of primary containers, but msut be embedded into detail View Panels, can't be referenced, and can't have toolbar associated.",
                "Input set widget": "Not reusable. Inherits parent root object. Created as widget in parent container's PCF.",
                "Input set PCF": "Reusable. Takes a root object. Created as separate PCF and filename ends with InputSet."
            },
            "Partial Page Update": {
                "Widget properties": "Static property and dynamic property.",
                "Static property": "Evaluates static value that is immutable.",
                "Dynamic property": "Evaluates expression on navigation and returns value. Expressions: available, editable, required, and visible. Reflects commited data.",
                "Dynamic behavior": "Evaluates expression while business data is changed. Reflects uncomitted data changes. Partial page update configuration required, either layout re-render or data update.",
                "Layout re-render": "Layout can be re-rendered dynamically based on user input, without data being comitted.",
                "Data update": "Responds upon users changing business data. Not after navigation or commit. More performant than re-rendering.",
                "disablePostOnEnter": "If evaluated true when page is rendered, this field won't trigger Post On Change.",
                "onChange": "Defines Gosu expression to invoke when user changes value of widget. Immediate post back to server."
            },
            "Subtypes": {
                "Subtype entity": "Entity that is child of supertype entity and inherits fields and method from supertype.",
                "Subtypes in database": "Typelist and entity table define supertype and subtype relationship. Supertype entity table contains subtype columns in denormalized form. Irrelevant columns for subtypes contain null.",
                "Subtypes in data dictionary": "Shown under parent entity listing.",
                "Subtypes and java classes": "Class methods, fields and properties can be extended to inherit from parent class. Uses extends keyword after class name declaration.",
                "Subtype limitations": "New subtypes inherit from supertype. Unable to inherit from multiple supertypes.",
                "Subtype entity extensions": "Base application comes with oOTB subtype entities. Can be extended the same way as top-level entities. Entity extensions are stored in ../configuration/config/extensions/Entity. Uses _Ext suffix for new fields in extension."
            },
            "Modes": {
                "Mode": "Property used for PCFs appropriate for given business scenario. Identifies scenario in which a PCF is used. Multiple PCFs must share ID, number, type and order of required variables, and one or more unique modes.",
                "Default mode": "Modal PCF sets include one PCF with mode value in lowercase default.",
                "Modes and subtypes": "Mode property recognizes explicitly specified subtypes. Not aware of subtype's hierarchy. Unspecified subtypes do not render."
            },
            "Entity Names": {
                "Entity name": "User interface friendly name for instance of given entity. Contains at least one default entity name type definition. Default definition acessible with entity DisplayName property.",
                "Entity name usage": "Displaying entity instance and explicitly referencing DisplayName property of entity instance.",
                "Undefined entity name": "Using DispalyName property for entity without enttity name type definition results in list of fields.",
                "Complex entity name type": "Perform operations: conditional logic, string manipulation, and calculations."
            }
        }
    },
    "PolicyCenter Introduction": {
        "Kickstart Lessons": {
            "Accounts": {
                "Account": "Provides the ability to store customer information separately from policies. Account can have zero or many associated policies. This flexibility is useful for controlling information visibility.",
                "Account holder": "People or companies can have an account.",
                "Relationship": "A single contact can contain multiple accounts. One person can be associated with multiple accounts.",
                "Account types": "Personal and business.",
                "Policy": "One policy can be associated with one account.",
                "Creating": "When account creation is requested, PolicyCenter initiates name clearance.",
                "Name clearance": "Validates that account name does not exist in database or is not already represented by another producer for the given policy.",
                "Producer": "Generic third party that brings business to insurer[s].",
                "Account supporting information": "Summary, contacts, locations, participants, transactions, submission manager, documents, policies and UW files, history, notes, and related account.",
                "Account Summary Dashboard": "Details about account holder, general overview of account, billing details, current activities, list of account policies, policy transactions, claims, related accounts, producers and locations."
            },
            "Policy Transactions": {
                "Policy transaction": "Coordinates work associated with creating and modfiying policies. Aduits are not included.",
                "Policy life span": "The duration of an active policy is determined by the effective date (start) and expiration date (end). The difference is the policy term. One or more transactions during the term can change the policy.",
                "Policy term": "Duration between the effective date and expiration date of a policy.",
                "Policy period": "A copy of the policy created after a job takes place. This copy handles version control and reflects new changes. A term with multiple periods is considered split.",
                "Job": "Synonymous with policy transaction. Used in configuration, while transaction is used in UI. When a policy is created or modified, a new policy period begins within the term.",
                "Submission": "Transaction that creates a policy and begins its term. Has a create date (initation), close date (completion), and effective date (legally binding). Submission does not take effect until candidate is deemed qualified and obtains one or more quotes.",
                "Policy change": "A policy change prior to its expiration date. Changes can be coverables added/removed from policy, coverages added/removed from coverables, and the coverage terms.",
                "Renewal": "Creates new policy at the end of its term. May involve policy changes. Non-renewed policies are considered expired. Customers may not renew because of better alternatives, and insurers may not renew because it is financially disadvantagous.",
                "Cancellation": "Ends policy before its expiration date. Can be initiated by insured or by insurer.",
                "Reinstatement": "Restores cancelled policy to original term. Has same effective date and converage. Can occur when issue is rectified, such as payment issue.",
                "Rewrite": "Creates new policy from existing policy. Typical when error occured and original policy is no longer representative of intent. Insurer-specific and thus no universal definition of cause.",
                "Mid-term rewrite": "Replaces portion of original term to allow rewrite of policy through original end date or to add new end date. May affect coverage (lapse).",
                "Rewrite new account": "Rewrites policy to new target account. Takes data from existing policy to create new policy with new number in new account. Only rewrites cancelled or expired policies to new account. Policy terms may be different.",
                "Audit": "Line of business (LOB) specific transactions. Submission of audit creates policy with premium based on estimations (e.g. insured's revenue).",
                "Premium report": "Collects periodic data within policy term, and can change policy premium.",
                "Final aduit": "May occur at end of term to ensure policy does not reflect estimated data.",
                "Job logic": "Occurs in six categories: job processes, workflow, wizard, product model, rules, and external systems.",
                "Job processes": "Control job flow and may use workflows",
                "Workflow": "Component to execute asynchronous custom business process. Can be invoked by job process class.",
                "Wizard": "Seris of screens for collecting information during job.",
                "Product model": "Defines structure of product, coverage availability, qualification questions asked. Configurable by Product Designer.",
                "Rules": "Check for simple conditions and execute actions.",
                "External systems": "Periodically called during job processing. Example: rating engine for quote.",
                "Job initiation": "Three ways: by users through action menu, by external systems through API, through batch processes.",
                "Policy history": "Timeline for policy that has been modified or not cancelled before renewal.",
                "PolicyPeriod": "Entity storing information for specific revision of policy period. Every change to policy is a new revision.",
                "Transaction dates": "Two dates: bind date and effective date.",
                "Bind date": "Date of transaction completion.",
                "View transactions": "Policy transactions link on account or policy page -> Account File or Policy File."
            },
            "Policy File": {
                "Policy file": "Zero to many relationship between accounts and policies.",
                "Policy Summary": "Provides details about specific policy. Read-only page. Policy details can be edited on Policy Info screen.",
                "Contact": "Person or organization. Can be the named insured[s].",
                "Location": "Physical location. May be referenced in policy. Can be created on account and reused on policy, or created on policy.",
                "Coverable": "Risk exposure that can be protected by policy.",
                "Coverage": "Protection from specific risk and always attached to coverable. Policy level or for specific coverable. Examples: collision property coverage protects vehicle and liability coverage protects insured.",
                "Property coverage": "Covers tangible assets belonging to insured.",
                "Liability coverage": "Covers liability of insured when damage is inflicted on third party.",
                "Coverage term": "Value limiting or defining coverage. Example: collision coverage has deductible and limit.",
                "Premium": "Price paid for policy by insured.",
                "Form": "Physical document describing aspect of policy. Examples: declaration sheet, base form, additinoal coverage form, and exclusion form."
            },
            "Product Model Introduction": {
                "Product model": "Backbone of PolicyCenter and where risk is defined through product configuration. Business logic, underwriting rules, forms, and rating are configured after product model.",
                "Policy file information": "Examples: available lines of business (LOB), available coverages for LOB, and coverage terms (limit or deductible).",
                "Base configuration": "Provides templates for LOBs that insurers can customize. LOBs are not products. Examples: business owners, commercial auto, commercial property, general liability, homeowners, inland marine, workers' compensation, and personal auto.",
                "Product": "The product covered by a policy. Examples: commercial package and commercial property.",
                "Product details": "Specific about product, configured in product model.",
                "Availability": "Applied at all levels within product model, and extensible with additional criteria. An available component appears in the live application. Availability is based on factors: start and end date, industry code, underwriting company, policy transaction type, jurisdiction, and policy type.",
                "Product Designer": "PolicyCenter tool for configuring product model. Business logic, underwriting rules, forms and rating are configured after product model.",
                "Advanced Product Designer (APD)": "Business tool insurers use to design insurance product based on business requirements using Xmind, simulate policy transactions, auto-generate product artifacts (entity model, product model, UI), build and launch product, and facilitate business-level product discussion with stakeholders."
            },
            "Full Application Submission": {
                "Submission process": "Producer or insurer creates policy and receives acceptance from policy holder.",
                "Rating and quoting management": "Performance can be improved through parallel rating, asynchronous quoting, and two-step quoting.",
                "Parallel rating": "Rates coverables in parallel using multiple threads.",
                "Asynchronous quoting": "Runs quote process in background. Occurs when enabled (AsynchronousQuotingEnabled = true in config.xml), coverables count exceeds threshold, and line supports it.",
                "Asynchronous quoting flow": "Click quote -> Alert message -> Runs in background, policy transaction locked -> Quoting complete, unlocks, creates activity -> Click activity subject to display quote page, if successful.",
                "Two-step quoting": "Validates policy date and rates policy, then completes post-rating tasks such as generating forms and raising underwrite issues.",
                "Two-step quoting flow": "Rate -> Quote."
            },
            "Policy Tools": {
                "Policy Tools": "Provides access to Policy File details: summary, billing, contacts, participants, policy transaction, notes, documents, risk analysis, reinsurance, history, and financial transactions.",
                "Summary": "Concise information about entire Policy File. Includes current activities, completed and pending policy transactions.",
                "Billing": "Overall balance or balances for individual policy periods.",
                "Contacts": "Lists contacts associated with policy. Basic contact information and role in activity per contact.",
                "Participants": "Lists users interacting with policy, sorted by role in policy. Participants can be altered.",
                "Policy transaction": "All policy transaction occured on plicy. Includes modifying, in-progress, withdrawn, not taken or non-renewed jobs.",
                "Notes": "Search and review notes related to policy or policy transaction.",
                "Documents": "Search and view atached dcouments related to policy or policy transaction. Not the same as Forms.",
                "Risk analysis": "Issues affecting policies. Underwriting issues represented as notes, may cause carrier to deny policy or raise premium. Displays claims, prior policies, prior losses, or contingencies.",
                "Reinsurance": "Transferred insurance risk from one company to another, for whole or part of assumed liability.",
                "History": "Search and view historical events on policy.",
                "Financial transactions": "Tool for rating during application development. Access requires internaltools permission."
            },
            "Policy Changes and Preemptions": {
                "Policy change": "A change transaction that alters policy terms prior to expiration date. Involves material change and frequently change to premium.",
                "Material change": "A change to policy affecting coverage.",
                "Effective date change": "Customers frequently need policy changes, which necessitates a change in effective date. Effective date can be edited after policy change starts and before it is issued. After policy is issued, a policy change transaction is required.",
                "Preemption": "Phenomenon occuring when two transactions are initiated from same base period. Occurs when new transaction is started while other transaction is in progress.",
                "Preempting job": "The first job preempts when two jobs are started from same base period, and the second job must be modified to handle preemption.",
                "Preemption warning": "Warning appears when new change is initiated before in-progress change is issued.",
                "Preempting transaction": "Policy Change Bound screen links to preempted transactions when occuring.",
                "Preempted transaction": "User is alerted about handling preemptions when attempting to complete preempted job.",
                "Handling preemption": "Conflicting changes are shown as branches and can be applied or withdrawn. If applied, the period of the first preempting job becomes base period for the second preempted job."
            },
            "Renewals": {
                "Renewal process": "Begins before current policy term expires.",
                "Renewals": "Extend policy into new term. Configurable in PolicyCenter.",
                "Renewal start": "Automated renewal or manual renewal",
                "Automated renewal": "Default. Typically starts configurable amount of days before expiration date, varying between policies.",
                "Manual renewal": "Overrides automated renewal, to renew before renewal date. May be used for policy changing at time of renewal.",
                "Renewal results": "Renewed, non-renewed, or not taken.",
                "Renewed": "Policy continues for another term after term ends.",
                "Non-renewed": "Insurer may choose not to renew for another term if financially unfavorable. Renewal regulations differ between jurisdictions.",
                "Not taken": "Insured may choose not to take renewal for another term if another policy or premium is more desirable.",
                "Short-term renewal": "Policy continues for another shortened term after term ends. This can be due to cancellation regulations dictating coverage continues for a short period.",
                "Renewal wizard": "Used by users to gather and display renewal information on manual renewals. Also used for referred renewals.",
                "Pre-renewal direcrtion": "A set of instructions describing renewal process, which users use to override automated renewal. Initiated by entering pre-renewal direction in expiring term. One active pre-renewal direction per policy."
            },
            "Cancellation, Reinstatement, and Rewrite": {
                "Cancellation transaction": "Policy must be cancelled to reinstate or rewrite.",
                "Cancellation": "Ends a policy before its expiration date. Varies by insurer and is configurable. Insureds can choose cancellation without reason, but insurers must demonstrate cause such as non-payment or fraud.",
                "Reinstatement": "Reinstates canceleld policy with original terms. Cancellation and reinstatement have same effective date. No lapse in coverage. Configurable.",
                "Rewrite": "A significant change to policy that can not be captured with policy change. Partial or full discard of original policy terms. Full-term rewrite or mid-term rewrite.",
                "Full-term rewrite": "Rewrites entire policy term, including beginning of term. Discards original policy term.",
                "Mid-term rewrite": "Rewrites remainder of policy term, excluding beginning of term."
            },
            "Out of Sequence Transactions": {
                "Out-of-sequence (OOS) transaction": "Transaction created after bound transaction with effective date before bound transaction is known as OOS transaction. OOS transactions can be policy change, cancellation, reinstatment, and rewrite, but not submission, renewal, or audit.",
                "Conflict": "Occurs when two transactions modify same field to different value. PolicyCenter merges data changes when there is no conflict, and requests user intervention when there is conflicting values."
            },
            "Users and Groups": {
                "User": "Individual interacting with PolicyCenter. They can perform policy transaction, look up policy status, manage activities, or assign rules, notes, attached documents, hitory, and team views. Users can belong to multiple groups.",
                "User types": "Internal user, external user, and captive agent. Roles and producer codes dictate access.",
                "Internal user": "Employee of insurer. Can potentially view external user groups and permissions.",
                "External user": "Person outside company with access to PolicyCenter. Typically a proucer.",
                "Captive agent": "Internal employee of insurer or external contracted workers for insurer.",
                "Group": "Collection of users, producer codes, queues, and regions. Created by administrator based on geography, divisions, and departments. Groups can contain sub-groups with users and producer codes. Multiple groups per user.",
                "User management": "Administration tab provides user search, viewing, editing, and creation. User details include ownership (user type) and access (roles, underwriting authority, and region).",
                "User access": "Users inherit group producer codes, but additional codes can be added per user.",
                "Group management": "Administration tab provides group search, viewing, editing, and creation.",
                "Team management": "Team tab provides supervisors and managers the tools to manage groups. It reports all activities and jobs grouped by time and status. Provides mass reassignment of activities and jobs. Displays policy transactions by role or activity."
            },
            "Organizations and Producer Codes": {
                "Organization": "Business entity representing insurer or agency.",
                "Producer": "Comissioned intermediary assiting insurer with policy underwriting for insureds. Identified by unique producer code.",
                "Internal producer": "Employee of the insurer. Sells insurance.",
                "External producer": "Belongs to external organization. May be referred to as independent agent.",
                "Producer types": "Producer of record or service.",
                "Producer of record": "Created submission and receives comission based on premium.",
                "Producer of service": "Services policy. If not also producer of record, then comission is received only after policy renewal.",
                "Producer code": "Unqieu ID assigned by insurer to track agent/agency responsibly for policy/account. Can track multiple policy categories per producer.",
                "Organization management": "Administration tab provides organization search, viewing, editing, and creation.",
                "Producer code management": "Superusers or useradmins can manage producer codes, users, groups and organizations. Producer codes can be searched, viewed, edited, and created.",
                "Delegate management": "Internal organization delegates management through useradmins to external company, which can also be accessed and managed by internal organization.",
                "Security": "Role-based or data-based security.",
                "Role-based security": "Permissions regulate abiltiy to view or perform granular task. Roles are collections of permission and typically map to job function or title.",
                "Data-based security": "Defines data access and typically managed through producer codes.",
                "Prducer code security": "Producer code controls daata acesss and determines available actions in collaboration with permissions.",
                "Status field": "Available for organizations and producer codes. Limits access after contract expiration and prevents misuse.",
                "External user access": "Configurable parameter External User Access in config.xml. Three access levels: FULLYRESTRICTED, PROTECTINTERNAL, and ALLOWINTERNAL.",
                "FULLYRESTRICTED": "Default. External users can only be assigned to their organization groups and producer codes.",
                "PROTECTINTERNAL": "External users can be assigned to any external group and producer codes.",
                "ALLOWINTERNAL": "External users can be assigned to any internal or external group and producer codes."
            },
            "Forms": {
                "Form": "Document describing aspect of policy. Contain legal information about policy. Part of policy contract. A form is not akin to an attached document, as it is part of the policy contract and legally binding. Examples: declaration sheets, base forms, additional coverage forms, exclusion forms, and manuscript forms.",
                "Form inference": "PolicyCenter generating form based on policy details. Logic typically defiend by form patterns. Example: user selects or add to policy a coverage, coverage term, typelist, additional insured type, or additinoal interest type.",
                "Form creation": "Form metadata and policy data is sent to the Document Production System (DPS), and afterwards stored in a document management system.",
                "Form pattern definition": "Valid forms that system can infer on policy. Requires permissions: formpatcreate, formpatview, formpatedit, and formpatdelete.",
                "Endorsement numbers": "Given to forms defined in form patterns. Numbers apply to specific policy period, beginning with 1 and increasing sequentially.",
                "Jurisdiction-specific form": "Added only for policies where geographical location is applicable to jurisdiction.",
                "Form multiplicity": "Multiple isntances of the same form. Requires configuration. Example: auto policy with multiple vehicles.",
                "Form editions and expiration": "When new jobs expire old form or data changes, a new form edition replaces it. PolicyCenter sets a removal date for old form and adds new form is inferred according to pattern."
            },
            "Introduction to Underwriting Authority": {
                "Underwriting process": "Agent/producer creates policy as submission transaction. If issue occurs and blocks quoting, approval is required from underwriter before policy is released back to agent.",
                "Underwriting authority": "Provides underwriting rules and infrastructure to manage issues. Major components: issue, rule, authority grant and profile.",
                "Underwriting issue": "Occurence of specific policy transaction where underwriting condition was true. Can stop jobs unless approved.",
                "Underwriting rule": "Describes impact of underwriting issues and how to resolve. Include conditions that raise issue.",
                "Authority grant": "Ability to approve issues and approval degree.",
                "Authority profile": "Group of authorities given to user, allowing user to approve issues.",
                "Creating issues": "Raised automatically based on policy choices. Rules trigger issues, and complex conditions can be written in Gosu. Automatically remvoed upon resolution. Can be added manually but then requires manual removal.",
                "Checking set": "Point in job where issues can be raised, including: pre-quote, bind, pre-insurrance. Used to specify when to check for issue existence.",
                "Blocking point": "Stops job progress until issue is approved. Issue types can be configured as informational (non-blocking)."
            },
            "Managing Underwriting Authority": {
                "Underwriting rule": "Defines underwriting issue type, specifies when to check, and conditions for raising issue. Editable and toggleable by authorized users. Importable, exportable, and deployable into different environment.",
                "Authority grant": "Allows users to approve specific issue. Added to authority profiles.",
                "Authority profile": "Type of underwriting issues users can approve. Often contain multiple authority grants. Allow fine-grained control.",
                "Rule deployment": "Create and test in development environment, then deploy to production environments. Rules can be urgently created in production environment.",
                "Rule life cycle": "On development server: draft (created) -> staged (ready). On production server: approved (ready) -> deployed (executes)."
            }
        },
        "Essentials Lessons": {
            "Products and Policy Lines": {
                "Policy line [pattern]": "A line of business. Includes set of legal and binding information about product. A product can have multiple policy line patterns. Can be used in different products, providing flexibility when creating new products in product model.",
                "Policy line subtype": "A pattern instance must connect to a subtype within its entity.",
                "Policy line features": "Includes line name and coverables.",
                "Product in PolicyCenter": "Captures marketing information about product. Easier to define after defining policy line. Considerations are business value, value proposition, relevancy to individuals/companies, items disqualifying applicants from purchase, availability, and policy lines inclusion.",
                "Product design": "Features: product type, product name, line of business, product account types, available jurisdictions, policy terms, and default policy term."
            },
            "Coverages": {
                "Coverable": "Exposure to risk and not explicitly defined in product model.",
                "Coverage": "Attached to coverable. Patterns in product model associated with relevant entity. Product model defines coverages and coverage terms.",
                "Coverage pattern attributes": "Attributes include covered object, category, availability, and existence.",
                "Covered object": "A coverable object must have a coverage table. A coverable can be associated with more than one coverage table. A policy has one database row for each coverage.",
                "Category": "A group of one or more logically related coverage patterns. Associates coverage patterns with policy line patterns. Coverages that appear together should be in the same category. Most commonly accepted coverages should be rendered as included, and less commonly rendered as additional.",
                "Availability": "When coverage appears on a policy.",
                "Existence": "An option that is either suggested, electable, or required.",
                "Subclause relationship": "Used for groups or families of coverages. Created in a mind map. Clause can ahve zero or one parent, multiple subclauses, and multiple levels of subclauses. Parent and subclause must be of same type."
            },
            "Coverage Terms": {
                "Coverage term": "Value measuring or further defining specific coverage. Coverage can have zero or many terms attached to it. Examples: deductible and limit. They are stored in coverage table.",
                "Coverage term attributes": "Includes term type and model type.",
                "Coverage term columns": "Coverage table has set number of columns for each term type. Number of coverage terms is limited to number of columns for type.",
                "Generic schedule": "List of detailed information about insured's coverables. Uses the generic schedule data model. Created/edited using Product Designer. Declaratively defined as XML in product model. Example: personal property in homeowner's policy.",
                "Schedule types": "Schedule or schedule with coverage terms.",
                "Schedule": "Captures information per scheduled item. Not directly used for rating. Usually included in forms.",
                "Schedule with coverage terms": "Captures information per scheduled item. Includes one or more coverages affecting rating. Includes one or more coverage terms.",
                "Add generic schedule to LOB": "Create generic schedule data model for line -> Configure scheduled clauses and properties in product model -> Optionally configure schedule user interface."
            },
            "Product Model Availability": {
                "Availability in product model": "Based on factors including effective start date, effective end date, industry code, underwriting company, and policy transaction type. Unavailable patterns are not exposed by PolicyCenter.",
                "Availability configuration": "Availability table lookup, availability script, and grandfather states.",
                "Availability script": "Consults availability table to determine available products, then passes available entities through script, which reduces nubmer of availableentities.",
                "Grandfathering": "Product model pattern becomes available if it already exists on policy, and thus can stay beyond its expiration date. It is determined by state, end effective date, and underwriting company.",
                "Reload availability": "Users can dynamically reload criteria for availability, by editing/saving availability data in product designer, copy/syncing xml to external directory, or by copying product model to external directory."
            },
            "Question Sets and Offerings": {
                "Question set": "Expedites underwriting. Has samples available in base configuration. Linked to product. Determines if person qualifies for product, before they enter wizard or through accumulated information. Not suitable for rating or integration.",
                "Offering": "Based on base product definition, and tailored to specific offering by insurerer. Customers can modify default values for coverages and coverage terms. Used for reaching specific customers.",
                "Offering availability": "Factors include start date, end date, job type, state, industry, and offering question set answers."
            },
            "Modifiers": {
                "Rate modifier": "Value used by rating engine to justify [portion of] policy premium. Captures information not tied to coverage or coverables but relevant to pricing.",
                "Modifier pattern": "Affects rating of coverages. Creates instance of modifier affecting cost of policy. Product-level modifiers are called ProductModifiers, and are applied to product only for multi-line policies.",
                "Schedule rate modifier": "Type of modifier proviiding credit or debit within established value range. Used for intangiables that cannot be quantified as part of submission.",
                "Rate factor": "Listed in the RateFactorType typelist before added to schedule rate in Product Designer."
            },
            "Contingencies": {
                "Contingency": "A part of the policy where the customer must provide additional information, such as a contingency-related document."
            },
            "Policy Holds and Underwriting Referral Reasons": {
                "Policy hold": "Placed on transaction due to natural disaster or business changes. Can be placed on region for specific time period. Prevents users from creating or changing policies. Underwriting issues can be raised during transaction when effective date is within policy hold, policy location matches affected region, and a proper underwriting authority is available.",
                "Hold and release": "Transactions are blocked, and underwriting issue needs to be resolved. Once approved the transaction is processed.",
                "Underwriting referral reason": "Used when notable condition arises outside transaction. Added manually or by external system through API. Not approvable but removable from policy.Raises issue on following transaction run in policy."
            },
            "Documents": {
                "Document": "Electronic file containing information about account, policy, or job. Not part of contract/policy.",
                "Document persistence": "Documents exist in the systems: user computer, PolicyCenter, production system, or document management system.",
                "Document creation": "Documents are created by uploading to document management system or through a PolicyCenter template which is also uploaded to document management system.",
                "Document production": "Creating a draft document through merging of template with business dataset. Underwriter can review and modify this draft document.",
                "Document production system": "Either internal in PolicyCenter or an external server that receives business data values and returns a draft document.",
                "Document storage integration": "PolicyCenter sends documents for storage, and receives stored documents upon request for viewing and editing. While being edited, a document is stored on the user device.",
                "Document management architecture": "Document management system returns document and a meta-file describing the document (author, security etc.).",
                "Document mailing": "Insurance documents are typically physically mailed to recipients. This is either accomplished by manually printing a document and mailing it, or by flagging a document in the document management system which forwards it to an automated printing/mailing system."
            },
            "Notes": {
                "Note": "Used by end-user to record details related to action, policy, account, job or contingency. Can be created in business rule. Plain text description, different from a document. Can be created with template. Does not integrate with third-party system.",
                "Note fields": "Topic, subject, security level, and text. Security level (unrestricted, internal, or sensitive) determines who can view the note."
            },
            "Activities": {
                "Activity": "Task or issue to be addressed. Associated with account, transaction, or policy. Can assign work to users based on process/users, alert users about events, and manage policy job completion. Added manually or automatically using business rules.",
                "Activity assignment": "Automatic or manual. Automatically added assignments are based on pre-defined business rules. Manually added assignments are based on user input, either requests to other users or reminders for oneself.",
                "Activity pattern": "Standardizes creation of activities through templates. Pattern specifies subject, priority, number of days until due etc. Managers can create/modify patterns in Administration tab of PolicyCenter. Configuration users can add pattern fields through data model based on customers requirements.",
                "Activity lifecycle": "In progress: new/updated -> In progress (viewed): normal -> Overdue -> Escalated -> Closed: completed or skipped.",
                "Activity types": "General activity or underwriter review. General activity does not require authorization. Underwrite review requires underwriters to review issues.",
                "Activity ownership": "Activities are assigned to users explicitly or implicitly. Explicit assignment assigns activities to users, and changes do not affect ownership. Implicit assignment assigns activities to roles, and changes to user roles can affect ownership.",
                "Activity queue": "Actvity repository associated with group. Users can take ownership of activities in queue. Users with actquenext role can self-assign activities. Base configuration delegates this role to underwriter role."
            },
            "Roles and Permissions": {
                "Access": "Ability to view/edit PolicyCenter based on user identity. These identities include superusers, underwriters, and external/user admins.",
                "Security in PolicyCenter": "Security is provided using roles, permissions, and producer codes. Users must have roles ti appropriate permissions. In base configuration superuser role has all permissions and permission delegation responsibility.",
                "System permissions": "Granular ability to view/edit PolicyCenter.",
                "Object permissions": "While some UI elements are displayed based on permissions, back-end function calls can have permissions. This means a UI element can be displayed but appear unavailable due to lack of permissions.",
                "User permissions": "Determined upon login and before authentication. A query is performed to retrieve permissions assigned to the user, determining which page is rendered.",
                "Role": "Named collection of permissions, used to simplify assignment to users.",
                "Role mapping": "Users can have one or more roles, and PolicyCenter does not have permissions restricting access.",
                "Role type": "Indicates entities available for assignment. Becomes producer code role when assigned to producer code. Producer code role can be assigned users or producer codes.",
                "Producer Code Security": "Users with security enabled can only use role permissions against policy with matching producer code.",
                "Role management": "Administration tab provides list view for displaying, creating and deleting roles. Requires superuser or manageroles permission.",
                "Security dictionary": "HTML pages documenting permissions and roles in application. Generated to <server directory\\build\\dictionary\\security\\index.html. Requires manual regeneration."
            },
            "Validation": {
                "Validation": "A check executed by PolicyCenter prior to executing action, ensuring validity of current business data. Ensures valid user input, that all necessary data has been entered, and manages data field relationship.",
                "Validation behaviors": "Validation can occur based on fields, upon save/update, and at levels in transaction.",
                "Field validator": "Handles simple validation of single field. Matching bassed on pattern or input mask. Restricts user input.",
                "Save validator": "Validation checks coded, and executed prior to comitting validatable entity to database. Required fields are marked with asterisk in UI. Present in business rule for validated entity.",
                "Job validator": "Validation checks coded as Gosu classes, executed as necessary. Base application uses to validate in relation to policy objects. Configurable warning or error on job level.",
                "Warnings and errors": "Warnings are non-blocking, meaning users can continue without clearing. Errors are blocking, meaning users can not continue without clearing. Typically appear at top of page if required fields are missing, or bottom of page in relation a button."
            },
            "Premium Audits": {
                "Audit": "Line of business (LOB) specific. Submission creates policy with premium based on estimation such as insured's revenue. Premium report collects actual data periodically within policy term, which can change policy premium. Final audit may occur at end of policy term to ensure policy reflects estimation.",
                "Audit type": "Final audit or premium report.",
                "Final audit": "Type of premium audit. Contains ultimate cost for variable basis policy. Automatically scheduled if needed by insurer, insurance laws or regulations. Conducted at expiration or cancellation of policy.",
                "Final audit process": "Schedule final audit -> Audit task batch process, starts audit job before policy expiration -> Audit policy -> No? Waive audit. Yes? Enter audit basis -> Calculate preium and complete audit -> Notify billing system to adjust premium.",
                "Premium report": "A secondary audit which may take place with regular intervals during policy term.",
                "Premium audit methods": "Physical, phome, estimated, or voluntary.",
                "Physical": "Representative makes in-person visit to policyholder and reviews business records, verifies, and obtains required audit information.",
                "Phone": "Auditor contacts policyholder by phone to obtain audit information.",
                "Estimated": "Used when other methods are unavailable, due to bankruptcy or loss of records.",
                "Voluntary": "Insurer distributes form to policyholder requesting audit information.",
                "Premium audit process": "Policy issued -> Add items (each item includes: process start date, due date, and audit method) -> Audit scheduled.",
                "Audit process": "Audit task starts (status: in progress) -> Audit, draft policy, transaction ready -> Items become links to audit wizard -> Enter audit details -> Calculate premiums -> Submit audit, non-editable (status: completed)."
            },
            "Rating Basics": {
                "Rating": "Process of determining policy cost.",
                "Rating output": "Information representing prices for portions of policy, such as coverage costs, taxes, or fees.",
                "Rating components": "Rating Engine, Rate book, Rate tables and Rate table definitions, and Rate routines.",
                "PolicyCenter rating": "Rate Flow, Rate Routines, Rate Tables, and Rate Books.",
                "Rate Flow": "Logic in rating engine that calculates premium.",
                "Rate Routines": "Algorithms calculating premium. Can specify mathematical operations, logic conditions, and varaible assignment from rate table lookup.",
                "Rate Tables": "Static rating content in lookup format.",
                "Rate Table Definition": "Parameters and factors for a rate table.",
                "Rate Books": "Group of rate tables and rate routines.",
                "Rating process": "Quote -> Rating Engine selects Rate Book -> Rating Engine calls Rate Routine for Cost Item -> Constructs Worksheet with calculated results."
            },
            "PolicyCenter Data Model": {
                "Primary entities": "There are two primary entities in the data model, Policy and Account.",
                "Major entities": "There are 25 major entities in the data model. These can be viewed as five groups.",
                "Policy group questions": "How does each policy period look? What is covered on policy? Who holds policy? What must be done for policy? Who is responsible for policy processing?",
                "Relationship": "Account can have one or more relationships to policy.",
                "Policy period": "Period of time where policy has not changed. A policy starts with a single period equivalent to its term. When it is renewed, a new period begins on the same policy. When it is changed, a new period begins on the same term.",
                "Policy line": "Captures majority of policy contents, such as coverables, coverages, and coverage terms. Product can be monoline or multiline.",
                "Coverable-specific entity": "Every coverable has its own entity and table. Coverables are database names for coverages.",
                "Line-specific entity": "Every policy line has a cost entity for storing costs and transaction entity for storing transactions. Transactions represent line items in a log of pricing changes. They live off the policy period and point to costs that they offset or onset. Onsetting refers to costs in the same period, while offsetting refers to based-on period costs.",
                "General policy line entity": "The six additional entities related to policy contents are PolicyLineAnswer, Modifier, RateFactor, PolicyContact, PolicyLocation, and Form.",
                "PolicyLineAnswer": "Entity storing answer sto questions in location and supllemental question sets.",
                "Modifier": "Entity storing modifiers for policy lines.",
                "RateFactor": "Entity storing rate factors for schedule rate modifiers.",
                "PolicyContact": "Entity storing contacts listed on policy. Linked to AccountContact entity.",
                "PolicyLocation": "Entity storing locations listed on policy. Linked to AccountLocation entity.",
                "Form": "Entity storing forms.",
                "Policy transaction entity": "As policy transactions are managed by jobs, their work is captured by the entities: Job, PeriodAnswer, Workflow, UWIssue, and Activity.",
                "Job": "Entity tracking work needed for each policy transaction.",
                "PeriodAnswer": "Entity storing answers for pre-qualification question set questions.",
                "Workflow": "Entity tracking workflows for policy period creation by job.",
                "UWIssue": "Entity storing policy evaluation issues.",
                "Activity": "Entity storing activities for completing policy transaction.",
                "User assignment": "Mulitple users are typically assigned to a policy, through role assignment in groups. The assignment engine can automatically assign roles using round robin selection. There are two types of ownership: Activity ownership and Role ownership.",
                "Activity ownership": "Object owned by single user holding sole responsibility. Occurs only for activities.",
                "Role ownership": "Object owned by multiple users holding a specific role, which determines their assigned activities.",
                "Account details": "The remaining major entities include Contact, AccountContact, AccountLocation, AccountProducerCode, Organization, and ProducerCode.",
                "Contact": "Entity storing contact information.",
                "AccountContact": "Entity linking contact to account.",
                "AccountLocation": "Entitity specifying account locations.",
                "AccountProducerCode": "Entity specifying associated producer codes for account.",
                "Organization": "Entity representing external non-account business entitites.",
                "ProducerCode": "Entity connecting policies to external organizations through specific producer codes."
            },
            "Concepts of Revisioning": {
                "EffDated entity": "Entity with effective date fields: start date (EffectiveDate) and end date (ExpirationDate). Used to track state of entity over effective time. Member of an effective dated graph, rootated at an effdatedbranch entity.",
                "Retireable entity": "Entity in extension of editable entity, and most common type of entity. Does not track state of entity.",
                "PolicyPeriod entity": "Root of all EffDated entities on policy graph. Not of type EffDated, but of type effDatedBranch.",
                "EffDated entity columns": "EffectiveDate and ExpirationDate, FixedId, Branch, and BasedOn.",
                "EffectiveDate and ExpirationDate": "Has same effective dates as its root if null.",
                "FixedId": "Unique identifier generated when object is created. Not nullable. Static for all versions of object.",
                "Branch": "Links to associated PolicyPeriod. Not nullable.",
                "BasedOn": "Pointer to prior version of enttiy. Noll if first version. Has column on EffDated and PolicyPeriod entity.",
                "Time dimensions": "Model time is real-world time for policy creation and job binding. Effective time is time dimension of the policy itself within policy period.",
                "Branch access modes": "Slice mode (API: getSlice(sliceDate)) is for viewing policy data as specific date in effective time. Window mode (API: VersionList, versionList.AllVersions, versionList.AsOf(date)) is for viewing versions of policy data across dates in effective time."
            }
        }
    },
    "PolicyCenter 10.0 Configuration": {
        "Kickstart Lessons": {
            "PolicyCenter Data Model": {
                "Primary entities": "There are two primary entities in the data model, Policy and Account.",
                "Major entities": "There are 25 major entities in the data model. These can be viewed as five groups.",
                "Policy group questions": "How does each policy period look? What is covered on policy? Who holds policy? What must be done for policy? Who is responsible for policy processing?",
                "Relationship": "Account can have one or more relationships to policy.",
                "Policy period": "Period of time where policy has not changed. A policy starts with a single period equivalent to its term. When it is renewed, a new period begins on the same policy. When it is changed, a new period begins on the same term.",
                "Policy line": "Captures majority of policy contents, such as coverables, coverages, and coverage terms. Product can be monoline or multiline.",
                "Coverable-specific entity": "Every coverable has its own entity and table. Coverables are database names for coverages.",
                "Line-specific entity": "Every policy line has a cost entity for storing costs and transaction entity for storing transactions. Transactions represent line items in a log of pricing changes. They live off the policy period and point to costs that they offset or onset. Onsetting refers to costs in the same period, while offsetting refers to based-on period costs.",
                "General policy line entity": "The six additional entities related to policy contents are PolicyLineAnswer, Modifier, RateFactor, PolicyContact, PolicyLocation, and Form.",
                "PolicyLineAnswer": "Entity storing answer sto questions in location and supllemental question sets.",
                "Modifier": "Entity storing modifiers for policy lines.",
                "RateFactor": "Entity storing rate factors for schedule rate modifiers.",
                "PolicyContact": "Entity storing contacts listed on policy. Linked to AccountContact entity.",
                "PolicyLocation": "Entity storing locations listed on policy. Linked to AccountLocation entity.",
                "Form": "Entity storing forms.",
                "Policy transaction entity": "As policy transactions are managed by jobs, their work is captured by the entities: Job, PeriodAnswer, Workflow, UWIssue, and Activity.",
                "Job": "Entity tracking work needed for each policy transaction.",
                "PeriodAnswer": "Entity storing answers for pre-qualification question set questions.",
                "Workflow": "Entity tracking workflows for policy period creation by job.",
                "UWIssue": "Entity storing policy evaluation issues.",
                "Activity": "Entity storing activities for completing policy transaction.",
                "User assignment": "Mulitple users are typically assigned to a policy, through role assignment in groups. The assignment engine can automatically assign roles using round robin selection. There are two types of ownership: Activity ownership and Role ownership.",
                "Activity ownership": "Object owned by single user holding sole responsibility. Occurs only for activities.",
                "Role ownership": "Object owned by multiple users holding a specific role, which determines their assigned activities.",
                "Account details": "The remaining major entities include Contact, AccountContact, AccountLocation, AccountProducerCode, Organization, and ProducerCode.",
                "Contact": "Entity storing contact information.",
                "AccountContact": "Entity linking contact to account.",
                "AccountLocation": "Entitity specifying account locations.",
                "AccountProducerCode": "Entity specifying associated producer codes for account.",
                "Organization": "Entity representing external non-account business entitites.",
                "ProducerCode": "Entity connecting policies to external organizations through specific producer codes."
            },
            "Configuring Location Groups and Pages": {
                "Location group": "Collection of locations providing structure and navigation for group of related pages, through menus and other interface elements.",
                "Page": "Location containing single screen in main frame. Used exclusively within location group. Menu link / location ref in sidebars points to page.",
                "Levels": "First-level navigation location group is pointed to from a tab. It is a parent-level group. Second-level navigation location group is contained within another group. It is a child-level group.",
                "Location group and page configuration": "Two levels of configuration are LocationGroup-level and Page-level.",
                "LocationGroup-level configuration": "Entry point, navigation to location group, MenuActions, TabBar, InfoBar, permissions to visit, and location refs.",
                "Page-level configuration": "Screen rendered by page, page logic (visibility, editability), and page labels.",
                "Location group PCF": "Includes information on entry points, required objects, location refs pointing to pages or child location groups, and attributes pointing to seaprate files for tab bar, info bar and menu actions.",
                "Location group entry points": "Location groups can have multiple entry points. Defined with EntryPointName(ObjectName: ObjectType). Each object used in entry point is defined as variable on Variables tab. Navigation from widget to location group through EntryPointOfLocation.go(objectsToPass).",
                "canVisit property": "Property that determines if user can visit location group. If property is not set, user can visit location group.",
                "Location group creation": "Create PCF of type Location Group -> Set essential information: title, entry point, objects in entry point, MenuActions, Infobar and TabBar -> Add location references to action property of navigation widget -> Deploy changes.",
                "Page PCF": "All embedded content will show in Studio. Pages are referenced by location refs in location groups through LocationPropertyOfLocationRef: EntryPointOfPage(objectsToPass).",
                "Page properties": "Pages are either in read-only or edit mode. The canEdit property determines if page has Edit/Update buttons. The startInEditMode determines if page renders in Edit mode. Page cannot start in Edit mode if canEdit is not true.",
                "Page creation": "Create PCF of type Page -> Set essential properties: title, entry point, objects in entry point. -> Add screen -> Include panels for viewable and/or editable content. -> Editable? Set canEdit property and add Edit Buttos to screen -> Add locationref widget to location group that will contain page."
            },
            "Configuring Job Wizards": {
                "Job wizard": "Location with one or more ordered screens, with one screen active at a time. Has a toolbar for navigating screens, access screens directly, have ordered screens, and navigation availability changes dynamically.",
                "Base application wizards": "Submissions, Renewal, Reinstatement, Policy Change, Audit, Cancelaltion, Rewrite, and Issuance.",
                "Job wizard architecture": "Consists of steps, with each step pointing directly to a screen. Steps are often grouped together into wizard step steps or step groups. Sets enable a single specificaton of logic to apply to multiple steps based on lines of business.",
                "Job wizard PCF": "Information includes entry points, required objects, steps pointing to sccreens, andZproperties pointign to separate files for tab bar, info bar, tool bar, and menu actions.",
                "Job wizard properties": "countsAsWork, canVisit, and canEdit.",
                "countsAasWork": "Allows users to resume the wizard after leaving without saving. Its status will be Unsaved Work in the same session.",
                "canVisit": "Property that determines if user can visit job wizard.",
                "canEdit": "Property that determines if user can edit job wizard.",
                "Wizard entry point and variables tab": "Entry point is defined with EntryPointName(objectName: ObjectType, ...). Variables tab declares objects expected in entry points. Navigate to job wizard through EntryPointName.go(objectsToPass).",
                "WizardStepGroup": "Wizards steps which are indented and have single parent label.",
                "WizardStepSet": "A set of wizard steps with shared logic. Directly insertable into wizard or wizard group.",
                "WizardStepSetRef": "Reference to PCF where step is stored.",
                "Independent steps": "Set the independent attribute of a step to true to make it independent.",
                "Ordered steps": "Order of steps in PCF determines order in application. Dependent steps are in top box. Independent stepss are in bottom box. Child steps are indented.",
                "Screen PCF": "Job wizard steps reference screens through ScreenPropertyOfJobWizardStep = EntryPointOfScreen(objectsToPass). PCF contains reference to embedded content. Screen labels are title and label. Buttons on screen are wizard buttons and toolbar buttons."
            },
            "Contacts and Locations": {
                "Contact": "Person or company. May need to be contacted for policy information. Can be created on account, reused on policy, or created on policy.",
                "Contact roles": "Account File Contacts page list all contacts on account. Contacts are identified by their role, and each contact can have multiple roles on an account and policy.",
                "Contact role behavior patterns": "Normal (array of contacts connected to entity), Singleton (single contact connected to entity), Simple Details (single contact with array of details), and Join Details (details join contact to other entity).",
                "Contact configuration plugin": "IContactConfigPlugin is used to configure contact entity, by mapping PolicyContactRole to AccountContactRole, controlling contact subtypes allowed for roles, and disabling role by setting first argument to false.",
                "Extending contact role data model": "Extensible contact role entities include PolicyContactRole, AccountContactRole, and all roles in default configuration. Roles can be defined for person, company, or both. Roles can be disabled when not needed.",
                "Contact role configuration strategy": "Add new contact role and configure to follow implementation of existing contact role. Do this by finding similar role in default configuration.",
                "Extending contact role entities": "Add extension file (*_Ext.ti) defining subtype (PolicyContactRole or AccountContactRole) -> modify registered Contact Config Plugin to map subtypes -> add display keys -> create entity name for contact role -> reference display name -> modify PCFs and Gosu classes -> retstart server to load entities and entity names.",
                "Location": "Physical location. May be referenced in policy. Can be created on account and reused on policy, or created on policy.",
                "Location numbering": "Locations are assigned sequential number by system. AccountLocation and PolicyLocation are numbered separately. Number is stored in LocationNum field, which is configurable based on carrier needs for numbering and renumbering locations within policies.",
                "LOB-specific location type": "Used when either coverages or coverables are attached to location. Subtypes of PolicyLine entity have associated location type. They have foreign key Location, pointing to PolicyLocation.",
                "Account location creation": "Call newLocation() method on account.",
                "Policy location creation": "Call newLocation() or newLocation(acctLoc: AccountLocation) on PolicyPeriod, were acctLoc is existing AccountLocation to which the policy location is associated."
            },
            "Concepts of Revisioning": {
                "EffDated entity": "Entity with effective date fields: start date (EffectiveDate) and end date (ExpirationDate). Used to track state of entity over effective time. Member of an effective dated graph, rootated at an effdatedbranch entity.",
                "Retireable entity": "Entity in extension of editable entity, and most common type of entity. Does not track state of entity.",
                "PolicyPeriod entity": "Root of all EffDated entities on policy graph. Not of type EffDated, but of type effDatedBranch.",
                "EffDated entity columns": "EffectiveDate and ExpirationDate, FixedId, Branch, and BasedOn.",
                "EffectiveDate and ExpirationDate": "Has same effective dates as its root if null.",
                "FixedId": "Unique identifier generated when object is created. Not nullable. Static for all versions of object.",
                "Branch": "Links to associated PolicyPeriod. Not nullable.",
                "BasedOn": "Pointer to prior version of enttiy. Noll if first version. Has column on EffDated and PolicyPeriod entity.",
                "Time dimensions": "Model time is real-world time for policy creation and job binding. Effective time is time dimension of the policy itself within policy period.",
                "Branch access modes": "Slice mode (API: getSlice(sliceDate)) is for viewing policy data as specific date in effective time. Window mode (API: VersionList, versionList.AllVersions, versionList.AsOf(date)) is for viewing versions of policy data across dates in effective time."
            },
            "Raising Underwriting Issues": {
                "Underwriting process": "Agent/producer creates policy as submission transaction. If issue occurs and blocks quoting, approval is required from underwriter before policy is released back to agent.",
                "Underwriting authority": "Provides underwriting rules and infrastructure to manage issues. Major components: issue, rule, authority grant and profile.",
                "Underwriting issue": "Occurence of specific policy transaction where underwriting condition was true. Can stop jobs unless approved.",
                "Underwriting rule": "Describes impact of underwriting issues and how to resolve. Include conditions that raise issue.",
                "Creating issues": "Raised automatically based on policy choices. Rules trigger issues, and complex conditions can be written in Gosu. Automatically remvoed upon resolution. Can be added manually but then requires manual removal.",
                "Checking set": "Point in job where issues can be raised, including: pre-quote, bind, pre-insurrance. Used to specify when to check for issue existence.",
                "Blocking point": "Stops job progress until issue is approved. Issue types can be configured as informational (non-blocking).",
                "Rule conditions": "Created using expressions in different modes (formula, count, sum, or lookup) and operands.",
                "Context definition": "Rule contexts are defined in the gw.bizrules.provisioning.contexts package. Objects can be added to context using addSymbol(objectName, objectType, objectPath) or addIterativeSymbol(objectName, objectType, objectPath). RuleContextDefinitionKey is a unique identifier for a context."
            },
            "Approving Underwriting Issues": {
                "Default Approval Value": "Calculated on underwriting issue approval page, based on values of Value Comparator, DefaultValueAssignmentType, and DefaultValueOffsetAmount.",
                "Authority grant": "Ability to approve issues and approval degree.",
                "Authority profile": "Group of authorities given to user, allowing user to approve issues."
            },
            "Validation Classes": {
                "Class-based validation": "Used on-demand, allowing users to choose time for validating data object, decide how to validate, and write complex valication logic as Gosu classes.",
                "Validation scope": "Class-based validation can be performed on policy-related objects such as PolicyContactRole, PolicyLocation, PolicyPeriod, LOB entities, and Policy-specifies entities. Everything in policy graph can be validated.",
                "Validation levels": "Validation restrictions decrease as priority value increases. Validation can be run at certain level on entity or wizard step. Check for validation pass and which level is currently being tested.",
                "Validation interfaces and classes": "PolicyCenter provides in the gw.validation package a PCValidation interface, PCValidationBase convenience class, PCValidationContext initialization class creating the PCValidationResult containing methods for generating warnings and errors.",
                "Validation classes in base configuration": "Classes shared across LOB are PolicyPeriodValidation, PolicyLineValdiation, PolicyLocationValidation, PolicyContactRoleValidation. LOB-specific class examples are BALineValidation and BusinessVehicleValidation.",
                "PCValidation implementation": "Validation classes must implement PCValidation or extend its classes. Entity validation classes extend PCValidationBase. PolicyLine validation classex extend PolicyLineValidation. Validation classes have a validateImpl() or doValidate() method.",
                "PCValidationContext": "Defined by the constructor of PCValidationBase. Context takes ValidationLevel for performing validation, and creates PCValidationResult for storing results (warnings and errors).",
                "PCValidationContext methods": "isAtLeast(valLevel) tests ValidationLevel, addToVisited(validation, methodName) traces validation logic, hasVisited(className, methodName) indicates if validation object and method in combination have been seen before, and showVisited() produces string of validation methods visited during validation.",
                "PCValidationResult": "Created by context methods. Class provides method for holding resulting warnings and errors.",
                "PCValidationResult methods": "addError(object, strRelativeFieldPath, valLevel, errorMessage, wizardStepId), addFieldError(object, strRelativeFieldPath, valLevel, errorMessage, wizardStepId), addWarning(pbject, valLevel, warningMessage, wizardStepId), addFieldWarning(object, strRelativeFieldPath, valLevel, warningMessage, wizardStepId), where valLevel means error or warning will be added at level or more restrictive level.",
                "Validation chaining": "Process of calling validation class from other validation class, adding an additional validation check, forming a chain of validatio checks.",
                "Validation chain flow": "Call validate() method which calls other methods -> Invoke validate() methodo n another validation class -> Classes chain to validations of entities they hold.",
                "Validation class creation": "New entities and LOBs require creation of new validation class, Existing entities can use existing validation class by adding validation check methods. New classes should extend PCValidationBase. Existing validation classes should be used as reference.",
                "Add validation check": "Add/edit appropriate vallidation class -> Add valication check method -> Call method from validateImpl() or doValidate() -> Invoke method -> Verify result in UI."
            }
        },
        "Essentials Lessons": {
            "Concepts of Revisioning Contacts and locations": {
                "Shared information": "Contact and location information is shared between accounts and policies. Avoids data re-entry and errors. Allows single contact to play multiple roles, such as account holder or named insured. Possible to associate Contact with entities Location or Vehicles. Information kept at Account level can be shared, avoiding duplication.",
                "Revisioning information": "Policies are versioned when issued, as they can be changed by an executed job.",
                "PolicyPeriod graph scope": "Data inside PolicyPeriod lives on both Policy and Account, while data outside lives only on Account. All of these entities have shared data, but only data inside PolicyPeriod is revisioned. Changes inside PolicyPeriod affect objects directly. Data such as contact name resides both inside and outside the PolicyPeriod graph.",
                "Handling current contact change": "Update <= Job Eff Date ? Current -> Sync data to Account and modify contact update time. Contacts always synced to account for submission and issuance.",
                "Handling future dated change": "Current date < Job Eff Date ? Future dated -> Copy from Account contact, Account and Policy not synced, create work item for pbatch process, apply pending account data updates, automatically update account-level contact on job date. Contact last update time is set when account levle contact information is modified.",
                "Handling back dated change": "Last update of contact > Job Eff Date ? Back dated -> Use policy-level data to make changes at policy level, create activities for changes at account level, create notes to specify changes.",
                "Location information": "Includes address, city, state location name, phone, and policy-specific information such as tax location. Location information is shared between accounts and policies and can be revisioned.",
                "Location revisioning": "Revisioned on field-by-field basis. Configurable by users. Locations that are part of policy contract are revisioned. Draft jobs always synchronize policy and account locations.",
                "Changing account location": "Affects pending policy transactions, quoted policy transactions, bound policies or completed policy transactions, and new policy transactions.",
                "Location configuration": "Extensible location-related entities are PolicyLocation, AccountLocation, and LOB-specific locations such as BOPLocation, IMLocation and CPLocation."
            },
            "Introduction to Permission Configuration": {
                "Creating system permissions": "Defined in SystempPermissionType typelist, where gray permissions are internal and not modifiable. Add permissions through typecodes, named as a verb in lowercase with no whitespaces. One-to-one relationship between permissions and actions. Permission code: [entity][action] (interchangable)",
                "Permission check in Gosu": "Gosu provides namespace perm to determine current user permissions, returning true or false. Syntax is perm.System.permission for system permissions defined in SystempermissionType typelist, and perm.Entity.permission for application permission keys. Permissions include visibility, editability, availability, and visitability, of atomic widgets, container widgets, and locations. Permissions can also be used to modify business rule behaviors.",
                "Application Permission Key (APK)": "A set of one or more system permissions defined in security-config.xml. APK uses custom handlers when mapping objects to system permissions. PolicyCenter defines APKs for objects: Account, PolicyPeriod, Jobs (submission, rewrite, policy change), Notes, Document,s and Activities.",
                "Static permissions": "No object argument taken. May use APKs.",
                "Object-based permissions": "Requires object argument. Requires APKs. Syntax is perm.Entity.permission(object)."
            },
            "Creating Activities": {
                "Activity": "Task or issue to be addressed. Associated with account, transaction, or policy. Can assign work to users based on process/users, alert users about events, and manage policy job completion. Added manually or automatically using business rules.",
                "Activity assignment": "Automatic or manual. Automatically added assignments are based on pre-defined business rules. Manually added assignments are based on user input, either requests to other users or reminders for oneself.",
                "Activity pattern": "Standardizes creation of activities through templates. Pattern specifies subject, priority, number of days until due etc. Managers can create/modify patterns in Administration tab of PolicyCenter. Configuration users can add pattern fields through data model based on customers requirements.",
                "Activity patterns in Gosu": "Two operations available, using activity pattern code to refer to activity pattern in Gosu. Test activity pattern used by existing activity: Entity.ActivityPattern.Code == \"pattern_code\". Retrieve activity pattern for creating new activity: ActivityPattern.finder.getActivityPatternByCode(\"pattern_code\").",
                "Account-related activity creation": "Gosu syntax is activityPattern.createAccountActivity(bundle, activityPattern, Account, subject, description, approvalIssue, priority, mandatory, targetDate, escalationDate). Alternative is account.newActivity(activityPattern).",
                "Policy-related activity creation": "Gosu syntax is activityPattern.createPolicyActivity(bundle, policy, subject, description, approvalIssue, priority, mandatory, targetDate, escalationDate). An activity is related to an account by default.",
                "Job-related activity creation": "Gosu syntax is activityPattern.createJobActivity(bundle, job, subject, description, approvalIssue, priority, mandatory, targetDate, escalationDate)."
            },
            "Assigning Activities": {
                "Assignable entities": "Business entities of type Primary or Role-based",
                "Primary assignment": "A primarily assignable entity requires Assignable and PCAssignable delegates, providing methods and fields for assignment. Has a single owner. Activity is a primary assignable entity.",
                "Role-based assignment": "Entity assigned a set of users with different roles. Applies to Account, Job (+subtypes) and Policy entities.",
                "Assignment execution flow": "Nothing specified -> Global Activity Assignment Rules -> Assigned to user? -> No? Default Group Activity Assignment Rules (group specified) -> Done (group and user specified).",
                "Activity ownership": "Activity are owned (assigned to) user and group. User must be member of assigned group. Assigning a user automatically assigns their default group. Activities assigned to users can only be edited by the assigned or a superior based on permissions. It can be viewed by other users of the same group.",
                "Activity queue": "Actvity repository associated with group. Users can take ownership of activities in queue. Users with actquenext role can self-assign activities. Base configuration delegates this role to underwriter role.",
                "Activity assignment": "Activities are assigned by assignment rules, classes, or both.",
                "Activity assignment rule sets": "An assignable entity has two rule sets. Assignment executes these rule sets. GlobalActivityAssignmentRules assigns activity to group/user, based on job role or OOTB Default rule (assign to underwriter). DefaultGroupActivityAssignmentRules assigns activity to user in assigned group, with round-robin rule.",
                "Activity assignment in Gosu": "The autoAssign() method uses the assignment engine to run assignment rules. Should not be called from within assignment rule. Alternatively other methods can be called within assignment classes.",
                "Assignment strategies": "Assign to group then round-robin among users (aware of permissions, configurable for workload/load factors). Assign to specific group and user. Assign to queue.",
                "Assignment methods": "Activity entity provides these methods for assignment rules and classes. The methods are assignGroup(), assignGroupByLocation(), assign(), assignUserAndDefaultGroup(), and assignActivityToQueue().",
                "Configurable classes": "Methods for modifying activity assignment logic are under gswrc/gw/assignment, such as AuditAssignmentEnhancement and JobAssignmentEnhancement.",
                "Assignment exit rule": "The method actions.exit() should be called after executing rule set, to prevent reassignment. A rule set should only be exited if its success evaluates to true. Assignment methods return Bool indicating success.",
                "Type/location-based group assignment": "Assignment for specified group type, region covering specified address, including direct or descendent child groups, and beginnig with children of specified group, using round robin. The syntax is object.assignGroupByLocation(groupType, address, directChildrenOnly, group)",
                "Location selection": "Using zones or regions. Zone is a geographic area, while region is a collection of specific zone values configured through Administration tab.",
                "Group assignment failure": "If assignment to group fails, then the object is assigend to a dummy user entitled Default Owner and root group of hierarchy.",
                "User assignment failure": "If assignment to user fails, then the assigned group rules are executed. If the object was not succesfully asigned to user or group, then it is assigned to supervisor of the current group. This behavior cannot be modified."
            },
            "The Job Lifecycle": {
                "<Jobtype> entities": "A Job is the parent entity, with subtypes including Submission, PolicyChange, Cancellation, Renewal, and Audit. The <Jobtype> object is instantiated when job starts and executes transaction on policy. It contains required data and can be enhanced or extended.",
                "Branch": "A set of objects related to PolicyPeriod object. A branch is one version of Policy, and is the core of a job (which also creates the branch).",
                "Job process": "Controls flow of a job using Gosu classes (such as SubmissionProcess.gs), wizard actions, and workflows. Flexible to user-driven logic.",
                "<Jobtype> process classes": "Gosu classes with methods for processing job, which are instantiated when required, and maintained in cache. Sub classes of JobProcess include SubmissionProcess, RenewalProcess, AuditProcess, and CancellationaProcess. Found in Studio path configuration -> gsrc -> gw -> job.",
                "<Jobtype> wizard": "Contains screens, tools and buttons to help user step through life cycle of job. The wizard helper is a Java class providing functionality such as movement between steps, visibility based on job state, and methods for adding messages. It has a Gosu enhancenment for adding additional functionality. Each job type has a button set that calls Gosu code to perform work, and they appear only in relevant wizard screens.",
                "Workflow": "Integration with users and external systems. Time-delayed actions, either relative or absolute.",
                "Starting job": "Three ways to start: by users through Actions menu, by external systems through API, or through PolicyCenter batch processes.",
                "Instantiating <Jobtype> object": "Typically by screen calling job wizard. Passed as parameter.",
                "Checking job conditions": "Preconditions checked before job function is performed. The Can methods return JobConditions object, which checks for error conditions, contains string builder entitled _messages, and derived property Okay of boolean type with value true if _messages is empty.",
                "Executing business logic": "Job wizzards calls methods on objects available in context, such as <Jobtype>Process, <JobType>Wizard, JobWizardHelper, and PolicyPeriod -> Job process methods call other methods and workflows -> Workflows call job process methods.",
                "End of job": "When branch is promoted (bound), withdrawn, or discarded. Job object remains in database and can be referenced but not edited. Job process object is discarded."
            }
        }
    }
}